"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-param-reassign */
const getUniqueId_1 = __importDefault(require("./getUniqueId"));
const perf_1 = __importDefault(require("./perf"));
const prepareProcessStack_1 = __importDefault(require("./prepareProcessStack"));
const createReadOnlyProxy_1 = __importDefault(require("./createReadOnlyProxy"));
const outputStyles_1 = __importDefault(require("./outputStyles"));
const mountComponentsInHtml_1 = __importDefault(require("../partialHydration/mountComponentsInHtml"));
const hydrateComponents_1 = __importDefault(require("../partialHydration/hydrateComponents"));
const buildPage = async (page) => {
    try {
        page.perf.end('initToBuildGap');
        await page.runHook('request', page);
        page.perf.start('data');
        if (typeof page.route.data === 'object') {
            page.data = { ...page.data, ...page.route.data };
        }
        else if (typeof page.route.data === 'function') {
            const dataResponse = await page.route.data({
                data: page.data,
                query: page.query,
                helpers: page.helpers,
                settings: createReadOnlyProxy_1.default(page.settings, 'settings', `${page.request.route}: data function`),
                request: createReadOnlyProxy_1.default(page.request, 'request', `${page.request.route}: data function`),
                errors: page.errors,
                perf: page.perf,
                allRequests: createReadOnlyProxy_1.default(page.allRequests, 'allRequests', `${page.request.route}: data function`),
                next: page.next,
            });
            if (dataResponse && Object.keys(dataResponse).length > 0) {
                page.data = {
                    ...page.data,
                    ...dataResponse,
                };
            }
        }
        page.perf.end('data');
        await page.runHook('data', page);
        if (page.shouldSkipRequest) {
            page.next();
            return page;
        }
        // start building templates
        page.perf.start('html.template');
        page.templateHtml = page.route.templateComponent({
            page,
            props: {
                data: page.data,
                helpers: page.helpers,
                settings: createReadOnlyProxy_1.default(page.settings, 'settings', `${page.request.route}: Svelte Template`),
                request: createReadOnlyProxy_1.default(page.request, 'request', `${page.request.route}: Svelte Template`),
            },
        });
        page.perf.end('html.template');
        page.perf.start('html.layout');
        page.layoutHtml = page.route.layoutComponent({
            page,
            props: {
                data: page.data,
                helpers: page.helpers,
                settings: createReadOnlyProxy_1.default(page.settings, 'settings', `${page.request.route}: Svelte Layout`),
                request: createReadOnlyProxy_1.default(page.request, 'request', `${page.request.route}: Svelte Layout`),
                templateHtml: page.templateHtml,
            },
        });
        page.perf.end('html.layout');
        await page.runHook('shortcodes', page);
        // shortcodes can add svelte components, so we have to process the resulting html accordingly.
        page.layoutHtml = mountComponentsInHtml_1.default({ page, html: page.layoutHtml, hydrateOptions: false });
        hydrateComponents_1.default(page);
        await page.runHook('stacks', page);
        // prepare for head hook
        page.head = page.processStack('headStack');
        page.cssString = '';
        page.cssString = page.processStack('cssStack');
        page.styleTag = outputStyles_1.default(page);
        page.headString = `${page.head}${page.styleTag}`;
        await page.runHook('head', page);
        // prepare for compileHtml
        const beforeHydrate = page.processStack('beforeHydrateStack');
        const hydrate = page.processStack('hydrateStack');
        page.htmlAttributesString = page.processStack('htmlAttributesStack');
        page.bodyAttributesString = page.processStack('bodyAttributesStack');
        const customJs = page.processStack('customJsStack');
        const footer = page.processStack('footerStack');
        page.footerString = `
    ${page.hydrateStack.length > 0 ? beforeHydrate : '' /* page.hydrateStack.length is correct here */}
    ${page.hydrateStack.length > 0 ? hydrate : ''}
    ${page.customJsStack.length > 0 ? customJs : ''}
    ${page.footerStack.length > 0 ? footer : ''}
    `;
        await page.runHook('compileHtml', page);
        await page.runHook('html', page);
        // disconnect timings so we don't get duplicates on next use of page.
        page.perf.end('page');
        page.perf.stop();
        page.timings = page.perf.timings;
        await page.runHook('requestComplete', page);
        if (page.errors.length > 0) {
            await page.runHook('error', page);
        }
    }
    catch (err) {
        console.log(err);
        page.errors.push(err);
        await page.runHook('error', page);
    }
    return page;
};
class Page {
    constructor({ request, settings, next = () => {
        console.error(`Cannot call next on a non SSR route ${this.route.name}`);
    }, query, helpers, data, route, runHook, allRequests, routes, errors, shortcodes, }) {
        this.uid = getUniqueId_1.default();
        this.request = request;
        this.settings = settings;
        perf_1.default(this);
        this.perf.start('page');
        this.perf.start('constructor');
        this.runHook = runHook;
        this.allRequests = allRequests;
        this.helpers = helpers;
        this.data = data;
        this.route = route;
        this.query = query;
        this.errors = [...errors];
        this.routes = routes;
        this.cssString = '';
        this.htmlString = '';
        this.htmlAttributesString = '';
        this.bodyAttributesString = '';
        this.bodyAttributesStack = [];
        this.htmlAttributesStack = [];
        this.headStack = [];
        this.cssStack = [];
        this.beforeHydrateStack = [];
        this.hydrateStack = [];
        this.customJsStack = [];
        this.footerStack = [];
        this.moduleJsStack = [];
        this.moduleStack = [];
        this.shortcodes = shortcodes;
        this.svelteCss = [];
        this.processStack = prepareProcessStack_1.default(this);
        this.perf.end('constructor');
        this.perf.start('initToBuildGap');
        this.shouldSkipRequest = false;
        this.next = () => {
            this.shouldSkipRequest = true;
        };
        this.resNext = next;
        this.componentsToHydrate = [];
    }
    build() {
        return buildPage(this).then((page) => page);
    }
    html() {
        if (this.htmlString) {
            return this.htmlString;
        }
        return buildPage(this).then((page) => page.htmlString);
    }
}
exports.default = Page;
