"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.devServer = exports.minifyCss = exports.getCssFromCache = exports.loadCss = exports.sortCss = exports.resolveFn = exports.resetDependencyCache = exports.getDependencyCache = exports.logDependency = exports.transformFn = exports.getCompilerOptions = exports.getDependencies = exports.cssFilePriority = exports.encodeSourceMap = void 0;
/* eslint-disable global-require */
/* eslint-disable no-param-reassign */
const path_1 = __importStar(require("path"));
const clean_css_1 = __importDefault(require("clean-css"));
const compiler_1 = require("svelte/compiler");
const spark_md5_1 = __importDefault(require("spark-md5"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const devalue_1 = __importDefault(require("devalue"));
const btoa_1 = __importDefault(require("btoa"));
const del_1 = __importDefault(require("del"));
const child_process_1 = require("child_process");
const chokidar_1 = __importDefault(require("chokidar"));
const partialHydration_1 = __importDefault(require("../partialHydration/partialHydration"));
const windowsPathFix_1 = __importDefault(require("../utils/windowsPathFix"));
let dependencyCache = {};
const cache = new Map();
const isDev = process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'PRODUCTION' && !!process.env.ROLLUP_WATCH;
let srcWatcher;
const mapIntro = `/*# sourceMappingURL=data:application/json;charset=utf-8;base64,`;
const encodeSourceMap = (map) => {
    if (!map || !map.toString)
        return '';
    return `${mapIntro}${btoa_1.default(map.toString())} */`;
};
exports.encodeSourceMap = encodeSourceMap;
const cssFilePriority = (pathStr) => {
    const normalizedPath = windowsPathFix_1.default(pathStr);
    if (normalizedPath.includes('node_modules'))
        return 6;
    if (normalizedPath.includes('src/layouts'))
        return 3;
    if (normalizedPath.includes('src/routes'))
        return 2;
    if (normalizedPath.includes('src/components'))
        return 1;
    return 0;
};
exports.cssFilePriority = cssFilePriority;
const getDependencies = (file) => {
    let dependencies = new Set([file]);
    if (dependencyCache[file]) {
        [...dependencyCache[file].values()]
            .filter((d) => d !== file)
            .forEach((dependency) => {
            dependencies = new Set([...dependencies, ...exports.getDependencies(dependency)]);
        });
    }
    return [...dependencies.values()];
};
exports.getDependencies = getDependencies;
const getCompilerOptions = ({ type }) => {
    const compilerOptions = {
        hydratable: true,
        generate: 'ssr',
        css: false,
        dev: isDev,
        format: 'esm',
    };
    if (type === 'client') {
        compilerOptions.generate = 'dom';
        compilerOptions.format = 'esm';
    }
    return compilerOptions;
};
exports.getCompilerOptions = getCompilerOptions;
function transformFn({ svelteConfig, elderConfig, type, }) {
    const compilerOptions = exports.getCompilerOptions({ type });
    const preprocessors = svelteConfig && Array.isArray(svelteConfig.preprocess)
        ? [...svelteConfig.preprocess, partialHydration_1.default]
        : [partialHydration_1.default];
    return async (code, id) => {
        const extensions = (svelteConfig && svelteConfig.extensions) || ['.svelte'];
        try {
            const extension = path_1.default.extname(id);
            // eslint-disable-next-line no-bitwise
            if (!~extensions.indexOf(extension))
                return null;
            // look in the cache
            const digest = spark_md5_1.default.hash(code + JSON.stringify(compilerOptions));
            if (cache.has(digest)) {
                return cache.get(digest);
            }
            const filename = path_1.default.relative(elderConfig.rootDir, id);
            const processed = await compiler_1.preprocess(code, preprocessors, { filename });
            // @ts-ignore - these types aren't in the type files... but if we don't pass in a map things break.
            if (processed.map)
                compilerOptions.sourcemap = processed.map;
            const compiled = await compiler_1.compile(processed.code, { ...compilerOptions, filename });
            // (compiled.warnings || []).forEach((warning) => {
            //   if (warning.code === 'css-unused-selector') return;
            //   this.warn(warning);
            // });
            const dependencies = exports.getDependencies(id);
            compiled.js.dependencies = [...dependencies, ...processed.dependencies];
            if (this.addWatchFile) {
                this.addWatchFile(id);
                compiled.js.dependencies.map((d) => this.addWatchFile(d));
            }
            if (type === 'ssr') {
                cache.set(`css${id}`, {
                    code: compiled.css.code || '',
                    map: compiled.css.map || '',
                    priority: exports.cssFilePriority(id),
                });
            }
            cache.set(digest, { output: compiled.js, warnings: compiled.warnings || [] });
            return { output: compiled.js, warnings: compiled.warnings || [] };
        }
        catch (e) {
            console.error('> Elder.js error in transform.', e);
            throw e;
        }
    };
}
exports.transformFn = transformFn;
function logDependency(importee, importer) {
    if (importee === 'svelte/internal' || importee === 'svelte')
        return;
    if (importer) {
        const parsedImporter = path_1.default.parse(importer);
        // The following two expressions are used to determine if we are trying to import
        // a svelte file from an external dependency and ensure that we add the correct path to that dependency
        const externalDependencyImport = path_1.default.resolve(parsedImporter.dir.substr(0, parsedImporter.dir.lastIndexOf('src')), 'node_modules', importee);
        const isExternalDependency = fs_extra_1.default.pathExistsSync(externalDependencyImport);
        if (!dependencyCache[importer])
            dependencyCache[importer] = new Set();
        if (importee.includes('node_modules')) {
            dependencyCache[importer].add(importee);
        }
        else if (importer.includes('node_modules')) {
            const fullImportee = path_1.default.resolve(parsedImporter.dir, importee);
            dependencyCache[importer].add(fullImportee);
        }
        else if (importee.includes('.svelte') && isExternalDependency) {
            dependencyCache[importer].add(externalDependencyImport);
        }
        else if ((parsedImporter.ext === '.svelte' && importee.includes('.svelte')) || importee.includes('.css')) {
            const fullImportee = path_1.default.resolve(parsedImporter.dir, importee);
            dependencyCache[importer].add(fullImportee);
        }
        else {
            dependencyCache[importer].add(importee);
        }
    }
    // eslint-disable-next-line consistent-return
    return dependencyCache;
}
exports.logDependency = logDependency;
function getDependencyCache() {
    return dependencyCache;
}
exports.getDependencyCache = getDependencyCache;
function resetDependencyCache() {
    dependencyCache = {};
}
exports.resetDependencyCache = resetDependencyCache;
// allows for injection of the cache and future sharing with esbuild
function resolveFn(importee, importer) {
    // build list of dependencies so we know what CSS to inject into the export.
    logDependency(importee, importer);
    // below largely adapted from the rollup svelte plugin
    // ----------------------------------------------
    if (!importer || importee[0] === '.' || importee[0] === '\0' || path_1.default.isAbsolute(importee))
        return null;
    // if this is a bare import, see if there's a valid pkg.svelte
    const parts = importee.split('/');
    let dir;
    let pkg;
    let name = parts.shift();
    if (name[0] === '@') {
        name += `/${parts.shift()}`;
    }
    try {
        const file = `.${path_1.default.sep}${['node_modules', name, 'package.json'].join(path_1.default.sep)}`;
        const resolved = path_1.default.resolve(process.cwd(), file);
        dir = path_1.default.dirname(resolved);
        // eslint-disable-next-line import/no-dynamic-require
        pkg = require(resolved);
    }
    catch (err) {
        if (err.code === 'MODULE_NOT_FOUND') {
            if (err.message && name !== 'svelte')
                console.log(err);
            return null;
        }
        throw err;
    }
    // use pkg.svelte
    if (parts.length === 0 && pkg.svelte) {
        const svelteResolve = path_1.default.resolve(dir, pkg.svelte);
        // console.log('-----------------', svelteResolve, name);
        logDependency(svelteResolve, name);
        return svelteResolve;
    }
    return null;
}
exports.resolveFn = resolveFn;
const sortCss = (css) => {
    return css
        .sort((a, b) => b[1].priority - a[1].priority)
        .reduce((out, cv) => {
        const o = {};
        o[cv[0]] = { styles: cv[1].code, sourceMap: cv[1].map };
        out.push(o);
        return out;
    }, []);
};
exports.sortCss = sortCss;
// eslint-disable-next-line consistent-return
function loadCss(id) {
    const extension = path_1.default.extname(id);
    // capture imported css
    if (extension === '.css') {
        const code = fs_extra_1.default.readFileSync(id, 'utf-8');
        cache.set(`css${id}`, {
            code,
            map: '',
            priority: 5,
        });
        return '';
    }
}
exports.loadCss = loadCss;
const getCssFromCache = (arr) => {
    const css = [];
    if (arr === 'all') {
        for (const [key, value] of cache.entries()) {
            if (key.indexOf('css') === 0) {
                const id = key.substr(3);
                css.push([id, value]);
            }
        }
    }
    else {
        for (const id of arr) {
            if (cache.has(`css${id}`))
                css.push([id, cache.get(`css${id}`)]);
        }
    }
    return css;
};
exports.getCssFromCache = getCssFromCache;
async function minifyCss(dependencies = [], elderConfig) {
    const css = exports.getCssFromCache(dependencies);
    const cleanCss = new clean_css_1.default({
        sourceMap: true,
        sourceMapInlineSources: true,
        level: isDev ? 0 : 1,
        rebaseTo: elderConfig.distDir,
        // rebase: elderConfig.distDir,
    });
    const sorted = exports.sortCss(css);
    return {
        ...cleanCss.minify(sorted),
        included: sorted ? sorted.map((m) => Object.keys(m)[0]) : [],
    };
}
exports.minifyCss = minifyCss;
const devServer = ({ elderConfig, forceStart = false, }) => {
    /**
     * Dev server bootstrapping and restarting.
     */
    let childProcess;
    let bootingServer = false;
    function startOrRestartServer(count = 0) {
        if (!isDev && !forceStart)
            return;
        if (!bootingServer) {
            bootingServer = true;
            const serverJs = path_1.default.resolve(process.cwd(), elderConfig.srcDir, './server.js');
            if (!fs_extra_1.default.existsSync(serverJs)) {
                console.error(`No server file found at ${serverJs}, unable to start dev server.`);
                return;
            }
            setTimeout(() => {
                // prevent multiple calls
                if (childProcess)
                    childProcess.kill('SIGINT');
                bootingServer = false;
                childProcess = child_process_1.fork(serverJs);
                childProcess.on('exit', (code) => {
                    if (code !== null) {
                        console.log(`> Elder.js process exited with code ${code}`);
                    }
                });
                childProcess.on('error', (err) => {
                    console.error(err);
                    if (count < 1) {
                        startOrRestartServer(count + 1);
                    }
                });
            }, 10);
        }
    }
    function handleChange(watchedPath) {
        const parsed = path_1.default.parse(watchedPath);
        if (parsed.ext !== '.svelte') {
            // prevents double reload as the compiled svelte templates are output
            startOrRestartServer();
        }
    }
    function startWatcher() {
        // notes: This is hard to reason about.
        // This should only after the initial client rollup as finished as it runs last. The srcWatcher should then live between reloads
        // until the watch process is killed.
        //
        // this should watch the ./src, elder.config.js, and the client side folders... trigging a restart of the server when something changes
        // We don't want to change when a svelte file changes because it will cause a double reload when rollup outputs the rebundled file.
        if ((isDev || forceStart) && !srcWatcher) {
            srcWatcher = chokidar_1.default.watch([
                path_1.default.resolve(process.cwd(), './src'),
                path_1.default.resolve(process.cwd(), './elder.config.js'),
                `${elderConfig.$$internal.distElder}/assets`,
                `${elderConfig.$$internal.distElder}/svelte`,
                path_1.default.join(elderConfig.$$internal.ssrComponents, 'components'),
                path_1.default.join(elderConfig.$$internal.ssrComponents, 'layouts'),
                path_1.default.join(elderConfig.$$internal.ssrComponents, 'routes'),
            ], {
                ignored: '*.svelte',
                usePolling: !/^(win32|darwin)$/.test(process.platform),
            });
            srcWatcher.on('change', (watchedPath) => handleChange(watchedPath));
            srcWatcher.on('add', (watchedPath) => handleChange(watchedPath));
        }
    }
    return {
        startWatcher,
        childProcess,
        startOrRestartServer,
    };
};
exports.devServer = devServer;
function elderjsRollup({ elderConfig, svelteConfig, type = 'ssr', startDevServer = false, }) {
    let styleCssHash;
    let styleCssMapHash;
    const { childProcess, startWatcher, startOrRestartServer } = exports.devServer({ elderConfig, forceStart: false });
    return {
        name: 'rollup-plugin-elder',
        watchChange(id) {
            // clean out dependency relationships on a file change.
            const prior = cache.get('dependencies');
            prior[id] = new Set();
            if (!dependencyCache)
                dependencyCache = {};
            dependencyCache = prior;
        },
        /**
         * Essentially what is happening here is that we need to say we're going to
         * emit these files before we know the content.
         * We are given a hash that we later use to populate them with data.
         */
        buildStart() {
            // kill server to prevent failures.
            if (childProcess)
                childProcess.kill('SIGINT');
            // create placeholder files to be filled later.
            if (type === 'ssr') {
                styleCssHash = this.emitFile({
                    type: 'asset',
                    name: 'svelte.css',
                });
                if (isDev) {
                    styleCssMapHash = this.emitFile({
                        type: 'asset',
                        name: 'svelte.css.map',
                    });
                }
            }
            // cleaning up folders that need to be deleted.
            if (type === 'ssr') {
                del_1.default.sync(elderConfig.$$internal.ssrComponents);
                del_1.default.sync(path_1.default.resolve(elderConfig.$$internal.distElder, `.${path_1.sep}assets${path_1.sep}`));
                del_1.default.sync(path_1.default.resolve(elderConfig.$$internal.distElder, `.${path_1.sep}props${path_1.sep}`));
            }
            else if (type === 'client') {
                del_1.default.sync(path_1.default.resolve(elderConfig.$$internal.distElder, `.${path_1.sep}svelte${path_1.sep}`));
            }
        },
        resolveId: resolveFn,
        load: loadCss,
        async transform(code, id) {
            const thisTransformFn = transformFn.bind(this);
            const r = await thisTransformFn({
                svelteConfig,
                elderConfig,
                type,
            })(code, id);
            if (!r)
                return;
            (r.warnings || []).forEach((warning) => {
                if (warning.code === 'css-unused-selector')
                    return;
                this.warn(warning);
            });
            // eslint-disable-next-line consistent-return
            return r.output;
        },
        // eslint-disable-next-line consistent-return
        async renderChunk(code, chunk) {
            if (chunk.isEntry) {
                if (type === 'ssr') {
                    const trackedDeps = exports.getDependencies(chunk.facadeModuleId);
                    const cssOutput = await minifyCss(trackedDeps, elderConfig);
                    code += `\nmodule.exports._css = ${devalue_1.default(cssOutput.styles)};`;
                    code += `\nmodule.exports._cssMap = ${devalue_1.default(exports.encodeSourceMap(cssOutput.sourceMap))};`;
                    code += `\nmodule.exports._cssIncluded = ${JSON.stringify(cssOutput.included.map((d) => path_1.default.relative(elderConfig.rootDir, d)))}`;
                    return { code, map: null };
                }
            }
        },
        /**
         * generateBundle is used to write all of the CSS to the file system
         * @param options
         * @param bundle
         * @param isWrite
         */
        // eslint-disable-next-line consistent-return
        async generateBundle() {
            // IMPORTANT!!!
            // all css is only available on the ssr version...
            // but we need to move the css to the client folder.
            if (type === 'ssr') {
                const { styles, sourceMap } = await minifyCss([...this.getModuleIds()], elderConfig);
                if (styleCssMapHash) {
                    // set the source later when we have it.
                    this.setAssetSource(styleCssMapHash, sourceMap.toString());
                    const sourceMapFile = this.getFileName(styleCssMapHash);
                    const sourceMapFileRel = `/${path_1.default.relative(elderConfig.distDir, path_1.default.resolve(elderConfig.$$internal.distElder, sourceMapFile))}`;
                    this.setAssetSource(styleCssHash, `${styles}\n /*# sourceMappingURL=${sourceMapFileRel} */`);
                }
                else if (styleCssHash) {
                    this.setAssetSource(styleCssHash, styles);
                }
            }
        },
        writeBundle() {
            if (type === 'ssr') {
                // copy over assets from the ssr folder to the client folder
                const ssrAssets = path_1.default.resolve(elderConfig.rootDir, `.${path_1.sep}___ELDER___${path_1.sep}compiled${path_1.sep}assets`);
                const clientAssets = path_1.default.resolve(elderConfig.$$internal.distElder, `.${path_1.sep}assets${path_1.sep}`);
                fs_extra_1.default.ensureDirSync(clientAssets);
                const open = fs_extra_1.default.readdirSync(ssrAssets);
                if (open.length > 0) {
                    open.forEach((name) => {
                        fs_extra_1.default.copyFileSync(path_1.default.join(ssrAssets, name), path_1.default.join(clientAssets, name));
                    });
                }
            }
            cache.set('dependencies', dependencyCache);
            if (startDevServer && type === 'client') {
                startWatcher();
                startOrRestartServer();
            }
        },
    };
}
exports.default = elderjsRollup;
