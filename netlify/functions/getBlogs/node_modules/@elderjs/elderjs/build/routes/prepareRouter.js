"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestFromDynamicRoute = exports.initialRequestIsWellFormed = exports.needsElderRequest = exports.findPrebuiltRequest = exports.getDynamicRoute = exports.extractDynamicRouteParams = void 0;
/* eslint-disable no-plusplus */
const route_sort_1 = __importDefault(require("route-sort"));
const lodash_get_1 = __importDefault(require("lodash.get"));
const Page_1 = __importDefault(require("../utils/Page"));
function extractDynamicRouteParams({ path, $$meta }) {
    let i = 0;
    const out = {};
    const ms = $$meta.pattern.exec(path);
    while (i < $$meta.keys.length) {
        out[$$meta.keys[i]] = ms[++i] || null;
    }
    return out;
}
exports.extractDynamicRouteParams = extractDynamicRouteParams;
function getDynamicRoute({ path, dynamicRoutes }) {
    let i = 0;
    for (; i < dynamicRoutes.length; i++) {
        if (dynamicRoutes[i].$$meta.pattern.test(path)) {
            return dynamicRoutes[i];
        }
    }
    return false;
}
exports.getDynamicRoute = getDynamicRoute;
const findPrebuiltRequest = ({ req, serverLookupObject }) => {
    // see if we have a request object with the path as is. (could include / or not.)
    let request = serverLookupObject[req.path] ? serverLookupObject[req.path] : false;
    if (!request && req.path[req.path.length - 1] === '/') {
        // check the req.path without a slash.
        request = serverLookupObject[req.path.substring(0, req.path.length - 1)];
    }
    else if (!request) {
        // check the req.path with a slash.
        request = serverLookupObject[`${req.path}/`];
    }
    if (request) {
        request.req = req;
    }
    return request;
};
exports.findPrebuiltRequest = findPrebuiltRequest;
// used to filter out requests which we know shouldn't be passed to the elder router.
const needsElderRequest = ({ req, prefix }) => {
    if (!req.path)
        return false;
    // check against prefix defined in elder.config.js
    if (prefix.length > 0 && !req.path.startsWith(prefix))
        return false;
    if (req.path.startsWith(`${prefix}/_elderjs/`))
        return false;
    return true;
};
exports.needsElderRequest = needsElderRequest;
// make sure we're dealing with a well form elderjs request.
const initialRequestIsWellFormed = (request) => !!(request && request.permalink && request.route);
exports.initialRequestIsWellFormed = initialRequestIsWellFormed;
function requestFromDynamicRoute({ req, dynamicRoutes, requestCache, }) {
    if (requestCache.has(req.path)) {
        const request = requestCache.get(req.path);
        request.req = req;
        return request;
    }
    const route = getDynamicRoute({ path: req.path, dynamicRoutes });
    if (route) {
        const params = extractDynamicRouteParams({ path: req.path, $$meta: route.$$meta });
        const request = {
            permalink: route.permalink({ request: params }),
            route: route.name,
            type: 'server',
            ...params,
        };
        requestCache.set(req.path, request);
        request.req = { ...req };
        return request;
    }
    return false;
}
exports.requestFromDynamicRoute = requestFromDynamicRoute;
function prepareRouter(Elder) {
    const { routes, serverLookupObject, settings, ...elder } = Elder;
    const requestCache = new Map();
    // sort the routes in order of specificity
    const dynamicRoutes = route_sort_1.default(Object.keys(routes).filter((cv) => routes[cv] && routes[cv].$$meta && routes[cv].$$meta.type === 'dynamic')).map((cv) => routes[cv]);
    const prefix = lodash_get_1.default(settings, '$$internal.serverPrefix', '');
    const forPage = {
        settings,
        routes,
        query: elder.query,
        helpers: elder.helpers,
        data: elder.data,
        runHook: elder.runHook,
        allRequests: elder.allRequests,
        errors: elder.errors,
        shortcodes: elder.shortcodes,
    };
    async function handleRequest({ res, next, request, dynamic = false }) {
        if (!request.route || typeof request.route !== 'string')
            return next();
        if (!routes[request.route])
            return next();
        const page = new Page_1.default({ ...forPage, request, next: dynamic ? next : undefined, route: routes[request.route] });
        const html = await page.html();
        // note: html will be undefined if a dynamic route calls skip() as it aborts page building.
        if (html && !res.headerSent && !res.headersSent) {
            res.setHeader('Content-Type', 'text/html');
            res.end(html);
            return undefined;
        }
        return next();
    }
    return async ({ req, res, next, request: initialRequest }) => {
        // if a prior middleware hook has already returned.
        if (!res.headerSent && !res.headersSent) {
            try {
                // initial request may be well formed if it is modified via a hook BEFORE the router runs.
                if (exports.initialRequestIsWellFormed(initialRequest))
                    return handleRequest({ res, next, request: initialRequest });
                if (!exports.needsElderRequest({ req, prefix }))
                    return next();
                const request = exports.findPrebuiltRequest({ req, serverLookupObject });
                if (request)
                    return handleRequest({ res, next, request: { ...request, ...initialRequest } });
                const dynamicRequest = requestFromDynamicRoute({ req, dynamicRoutes, requestCache });
                if (dynamicRequest)
                    return handleRequest({ res, next, request: { ...dynamicRequest, ...initialRequest }, dynamic: true });
                return next();
            }
            catch (e) {
                console.error(e);
                // should fall through to 404
                return next();
            }
        }
        else {
            return undefined;
        }
    };
}
exports.default = prepareRouter;
