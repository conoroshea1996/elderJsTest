"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.partialHydration = exports.build = exports.Elder = void 0;
/* eslint-disable global-require */
/* eslint-disable import/no-dynamic-require */
const path_1 = __importDefault(require("path"));
const routes_1 = __importDefault(require("./routes/routes"));
const plugins_1 = __importDefault(require("./plugins"));
const hookInterface_1 = require("./hooks/hookInterface");
const hooks_1 = __importDefault(require("./hooks"));
const build_1 = __importDefault(require("./build/build"));
exports.build = build_1.default;
const partialHydration_1 = __importDefault(require("./partialHydration/partialHydration"));
exports.partialHydration = partialHydration_1.default;
const utils_1 = require("./utils");
const createReadOnlyProxy_1 = __importDefault(require("./utils/createReadOnlyProxy"));
const workerBuild_1 = __importDefault(require("./workerBuild"));
const inlineSvelteComponent_1 = require("./partialHydration/inlineSvelteComponent");
const shortcodes_1 = __importDefault(require("./shortcodes"));
const prepareRouter_1 = __importDefault(require("./routes/prepareRouter"));
class Elder {
    constructor(initializationOptions = {}) {
        const initialOptions = { ...initializationOptions };
        this.bootstrapComplete = new Promise((resolve) => {
            this.markBootstrapComplete = resolve;
        });
        // merge the given config with the project and defaults;
        this.settings = utils_1.getConfig(initializationOptions);
        // overwrite anything that needs to be overwritten for legacy reasons based on the initialConfig
        // todo: this can be refactored into getConfig.
        this.settings.context = typeof initialOptions.context !== 'undefined' ? initialOptions.context : 'unknown';
        this.settings.server = initialOptions.context === 'server' && this.settings.server;
        this.settings.build = initialOptions.context === 'build' && this.settings.build;
        this.settings.worker = !!initialOptions.worker;
        if (this.settings.context === 'build') {
            this.settings.debug.automagic = false;
        }
        if (this.settings.context === 'server') {
            this.server = utils_1.prepareServer({ bootstrapComplete: this.bootstrapComplete });
        }
        // plugins are run first as they have routes, hooks, and shortcodes.
        plugins_1.default(this).then(async ({ pluginRoutes, pluginHooks, pluginShortcodes }) => {
            /**
             * Finalize Routes
             * Add in user routes
             * Add in plugin routes
             * Validate them
             */
            // add meta to routes and collect hooks from routes
            const userRoutesJsFile = routes_1.default(this.settings);
            // plugins should never overwrite user routes.
            const collectedRoutes = { ...pluginRoutes, ...userRoutesJsFile };
            const validatedRoutes = {};
            const collectedRouteNames = Object.keys(collectedRoutes);
            collectedRouteNames.forEach((collectedRouteName) => {
                const collectedRoute = collectedRoutes[collectedRouteName];
                const validated = utils_1.validateRoute(collectedRoute, collectedRouteName);
                if (validated) {
                    validatedRoutes[collectedRouteName] = validated;
                }
            });
            this.routes = validatedRoutes;
            /**
             * Finalize hooks
             * Import User Hooks.js
             * Validate Hooks
             * Filter out hooks that are disabled.
             */
            let hooksJs = [];
            const hookSrcPath = path_1.default.resolve(this.settings.srcDir, './hooks.js');
            try {
                const hooksReq = require(hookSrcPath);
                const hookSrcFile = hooksReq.default || hooksReq;
                hooksJs = hookSrcFile.map((hook) => ({
                    ...hook,
                    $$meta: {
                        type: 'hooks.js',
                        addedBy: 'hooks.js',
                    },
                }));
            }
            catch (err) {
                if (err.code === 'MODULE_NOT_FOUND') {
                    console.error(`Could not load hooks file from ${hookSrcPath}.`);
                }
                else {
                    console.error(err);
                }
            }
            // validate hooks
            const elderJsHooks = hooks_1.default.map((hook) => ({
                ...hook,
                $$meta: {
                    type: 'internal',
                    addedBy: 'elder.js',
                },
            }));
            // validate hooks
            this.hooks = [...elderJsHooks, ...pluginHooks, ...hooksJs]
                .map((hook) => utils_1.validateHook(hook))
                .filter(Boolean);
            if (this.settings.hooks.disable && this.settings.hooks.disable.length > 0) {
                this.hooks = this.hooks.filter((h) => !this.settings.hooks.disable.includes(h.name));
            }
            /**
             * Finalize Shortcodes
             * Import User Shortcodes.js
             * Validate Shortcodes
             */
            let shortcodesJs = [];
            const shortcodeSrcPath = path_1.default.resolve(this.settings.srcDir, './shortcodes.js');
            try {
                const shortcodeReq = require(shortcodeSrcPath);
                const shortcodes = shortcodeReq.default || shortcodeReq;
                shortcodesJs = shortcodes.map((shortcode) => ({
                    ...shortcode,
                    $$meta: {
                        type: 'shortcodes.js',
                        addedBy: 'shortcodes.js',
                    },
                }));
            }
            catch (err) {
                if (err.code === 'MODULE_NOT_FOUND') {
                    console.error(`Could not load shortcodes file from ${shortcodeSrcPath}. They are not required, but could be useful.`);
                }
                else {
                    console.error(err);
                }
            }
            // validate shortcodes
            this.shortcodes = [...shortcodes_1.default, ...pluginShortcodes, ...shortcodesJs]
                .map((shortcode) => utils_1.validateShortcode(shortcode))
                .filter(Boolean);
            /**
             *
             * Almost ready for customize hooks and bootstrap
             * Just wire up the last few things.
             */
            this.data = {};
            this.query = {};
            this.allRequests = [];
            this.serverLookupObject = {};
            this.errors = [];
            this.hookInterface = hookInterface_1.hookInterface;
            this.helpers = {
                permalinks: utils_1.permalinks({ routes: this.routes, settings: this.settings }),
                inlineSvelteComponent: inlineSvelteComponent_1.inlineSvelteComponent,
                shortcode: utils_1.prepareInlineShortcode({ settings: this.settings }),
            };
            // customizeHooks should not be used by plugins. Plugins should use their own closure to manage data and be side effect free.
            const hooksMinusPlugins = this.hooks.filter((h) => h.$$meta.type !== 'plugin');
            this.runHook = utils_1.prepareRunHook({
                hooks: hooksMinusPlugins,
                allSupportedHooks: hookInterface_1.hookInterface,
                settings: this.settings,
            });
            this.runHook('customizeHooks', this).then(async () => {
                // we now have any customizations to the hookInterface.
                // we need to rebuild runHook with these customizations.
                this.runHook = utils_1.prepareRunHook({
                    hooks: this.hooks,
                    allSupportedHooks: hookInterface_1.hookInterface,
                    settings: this.settings,
                });
                await this.runHook('bootstrap', this);
                // collect all of our requests
                await utils_1.asyncForEach(Object.keys(this.routes), async (routeName) => {
                    const route = this.routes[routeName];
                    let allRequestsForRoute = [];
                    if (typeof route.all === 'function') {
                        allRequestsForRoute = await route.all({
                            settings: createReadOnlyProxy_1.default(this.settings, 'settings', `${routeName} all function`),
                            query: createReadOnlyProxy_1.default(this.query, 'query', `${routeName} all function`),
                            helpers: createReadOnlyProxy_1.default(this.helpers, 'helpers', `${routeName} all function`),
                            data: createReadOnlyProxy_1.default(this.data, 'data', `${routeName} all function`),
                        });
                    }
                    else if (Array.isArray(route.all)) {
                        allRequestsForRoute = route.all;
                    }
                    if (!Array.isArray(allRequestsForRoute)) {
                        throw new Error(`${routeName}'s all() function isn't returning an array`);
                    }
                    allRequestsForRoute = allRequestsForRoute.reduce((out, cv) => {
                        // copy the obj so we don't have pass by reference issues.
                        const copy = JSON.parse(JSON.stringify(cv));
                        // add in routeName
                        copy.route = routeName;
                        out.push(copy);
                        return out;
                    }, []);
                    this.allRequests = this.allRequests.concat(allRequestsForRoute);
                });
                await this.runHook('allRequests', this);
                await utils_1.asyncForEach(this.allRequests, async (request) => {
                    if (!this.routes[request.route] || !this.routes[request.route].permalink) {
                        if (!request.route) {
                            console.error(`Request is missing a 'route' key. This usually happens when request objects have been added to the allRequests array via a hook or plugin. ${JSON.stringify(request)}`);
                        }
                        else {
                            console.error(`Request missing permalink but has request.route defined. This shouldn't be an Elder.js issue but if you believe it could be please create an issue. ${JSON.stringify(request)}`);
                        }
                    }
                    request.type = this.settings.context;
                    request.permalink = await this.routes[request.route].permalink({
                        request,
                        settings: createReadOnlyProxy_1.default(this.settings, 'settings', `${request.route} permalink function`),
                        helpers: createReadOnlyProxy_1.default(this.helpers, 'helpers', `${request.route} permalink function`),
                    });
                    if (this.settings.context === 'server') {
                        this.serverLookupObject[request.permalink] = request;
                    }
                });
                if (this.allRequests.length !== new Set(this.allRequests.map((r) => r.permalink)).size) {
                    // useful error logging for when there are duplicate permalinks.
                    for (let i = 0, l = this.allRequests.length; i < l; i += 1) {
                        for (let ii = 0, li = this.allRequests.length; ii < li; ii += 1) {
                            if (i !== ii && this.allRequests[i].permalink === this.allRequests[ii].permalink) {
                                throw new Error(`Duplicate permalinks detected. Here are the relevant requests: ${JSON.stringify(this.allRequests[i])} and ${JSON.stringify(this.allRequests[ii])}`);
                            }
                        }
                    }
                }
                this.router = prepareRouter_1.default(this);
                this.markBootstrapComplete(this);
            });
        });
    }
    bootstrap() {
        return this.bootstrapComplete;
    }
    worker(workerRequests) {
        return workerBuild_1.default({ bootstrapComplete: this.bootstrapComplete, workerRequests });
    }
}
exports.Elder = Elder;
